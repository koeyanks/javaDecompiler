package com.sopiana.yang.javaDecompiler.component;

import com.sopiana.yang.javaDecompiler.util.Util;

/**
 * Provides abstraction for <code>methods</code> item in <code>ClassFile</code> structure
 * 
 * <p>Each method, including each instance initialization method and the class or interface initialization method, 
 * is described by a <code>method_info</code> structure.</p>
 * <p>No two methods in one class file may have the same name and descriptor.</p>
 * <p>The structure has the following format:</p>
 * <code>method_info {<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;u2 access_flags;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;u2 name_index;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;u2 descriptor_index;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;u2 attributes_count;<br>
 * &nbsp;&nbsp;&nbsp;&nbsp;attribute_info attributes[attributes_count];<br>
 * }</code>
 * @author yang.sopiana
 *
 */
public class method_info extends class_info
{
	/**
	 *  <code>access_flags</code> shows that a method is declared <code>public</code>; may be accessed from outside its package.
	 */
	public static final short ACC_PUBLIC 	= 0x0001;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>private</code>; accessible only within the defining class.
	 */
	public static final short ACC_PRIVATE 	= 0x0002;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>protected</code>; may be accessed within subclasses.
	 */
	public static final short ACC_PROTECTED = 0x0004;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>static</code>.
	 */
	public static final short ACC_STATIC 	= 0x0008;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>final</code>; must not be overridden.
	 */
	public static final short ACC_FINAL 	= 0x0010;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>synchronized</code>; invocation is wrapped by a monitor use.
	 */
	public static final short ACC_SYNCHRONIZED 	= 0x0020;
	/**
	 * <code>access_flags</code> shows that a method is a bridge method, generated by the compiler.
	 */
	public static final short ACC_BRIDGE 	= 0x0040;
	/**
	 * <code>access_flags</code> shows that a method is declared with variable number of arguments.
	 */
	public static final short ACC_VARARGS 	= 0x0080;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>native</code>; implemented in a language other than Java.
	 */
	public static final short ACC_NATIVE 	= 0x0100;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>abstract</code>; no implementation is provided.
	 */
	public static final short ACC_ABSTRACT 	= 0x0400;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>strictfp</code>; floating-point mode is FP-strict.
	 */
	public static final short ACC_STRICT 	= 0x0800;
	/**
	 * <code>access_flags</code> shows that a method is declared <code>synthetic</code>; not present in the source code. 
	 */
	public static final short ACC_SYNTHETIC = 0x1000;
	
	/**
	 * The value of the <code>access_flags</code> item is a mask of flags used to denote access permission to and properties of 
	 * this method. The interpretation of each flag, when set, is specified by <code>ACC_xx</code> constants
	 */
	private short access_flags;
	/**
	 * The value of the <code>name_index</code> item must be a valid index into the <code>constant_pool</code> table. 
	 * The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure 
	 * representing either one of the special method names <code>&lt;init&gt;</code> or <code>&lt;clinit&gt;</code>, 
	 * or a valid unqualified name denoting a method.
	 */
	private short name_index;
	/**
	 * The value of the <code>descriptor_index</code> item must be a valid index into the <code>constant_pool</code> 
	 * table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure 
	 * representing a valid method descriptor.
	 */
	private short descriptor_index;
	/**
	 * The value of the <code>attributes_count</code> item indicates the number of additional attributes of this method.
	 */
	private short attributes_count;
	/**
	 * Each value of the attributes table must be an attribute_info structure.<br> 
	 * A method can have any number of optional attributes associated with it.
	 */
	private attribute_info attributes[];
	/**
	 * Factory method to generate a <code>methods</code> entry from given array of byte in specific offset.
	 * 
	 * <p>Each <code>methods</code> should begin with 2 bytes of <code>access_flags</code> describing access modifier 
	 * on a method, followed by 2 bytes of <code>name_index</code> describing method's name, 2 bytes of <code>descriptor_index</code> 
	 * method descriptor and variable length of <code>attribute_info</code> structures table.</p>
	 * @param classFileData byte array from the class file
	 * @param offset starting index to <code>classFileData</code>
	 * @param constant_pool <code>constant_pool</code> entry of a class
	 * @return instance of <code>method_info</code>
	 * @throws decompilerException if supplied <code>classFileData</code> is not a Valid <code>method_info</code>
	 */
	public static method_info getInstance(byte[]classFileData, int offset,cp_info[] constant_pool) throws decompilerException
	{
		method_info res = new method_info();
		res.offset = offset;
    	res.access_flags = Util.byte2Short(classFileData,offset);offset+=2;
    	res.name_index = Util.byte2Short(classFileData,offset);offset+=2;
    	res.descriptor_index = Util.byte2Short(classFileData,offset);offset+=2;
    	res.attributes_count = Util.byte2Short(classFileData,offset);offset+=2;
    	res.attributes = new attribute_info[res.attributes_count];
    	for(int i=0;i<res.attributes_count;++i)
    	{
    		res.attributes[i] = attribute_info.getInstance(classFileData, offset, constant_pool);
    		offset += res.attributes[i].getSize();
    	}
    	return res;
	}
    
	/**
	 * Accessor method to <code>size</code> field
	 * 
	 * <p>Showing <code>methods</code> entry in 8-bit cells byte including size of <code>tag</code>, <code>access_flag</code>
	 * <code>descriptor_index</code> and <code>attributes</code> table.
	 * @return size of <code>methods</code> entry
	 */
    public int getSize()
	{
    	int len = 8;
    	for(int i=0;i<attributes_count;++i)
    		len+=attributes[i].getSize();
    	return len;
	}
    
    /**
     * Accessor method to <code>access_flags</code> field
     * 
     * <p>The value of the <code>access_flags</code> item is a mask of flags used to denote access permission to and properties of 
	 * this method. The interpretation of each flag, when set, is specified by <code>ACC_xx</code> constants</p>
     * @return value of <code>access_flags</code> field
     */
    public short getAccess_flags() { return access_flags; }
    /**
     * Accessor method to <code>name_index</code> field
     * 
     * <p>The value of the <code>name_index</code> item must be a valid index into the <code>constant_pool</code> table. 
	 * The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure 
	 * representing either one of the special method names <code>&lt;init&gt;</code> or <code>&lt;clinit&gt;</code>, 
	 * or a valid unqualified name denoting a method.</p>
     * @return value of <code>access_flags</code> field
     */
    public int getName_index() { return (name_index&0xFFFF); }
    /**
     * Accessor method to <code>descriptor_index</code> field
     * 
     * <p>The value of the <code>descriptor_index</code> item must be a valid index into the <code>constant_pool</code> 
	 * table. The <code>constant_pool</code> entry at that index must be a <code>CONSTANT_Utf8_info</code> structure 
	 * representing a valid method descriptor.</p>
     * @return value of <code>access_flags</code> field
     */
    public int getDescriptor_index() { return descriptor_index; }
	/**
	 * Accessor method to <code>attributes_count</code> field
	 * 
	 * <p>The value of the <code>attributes_count</code> item indicates the number of additional attributes of this method.</p>
	 * @return value of <code>access_flags</code> field
	 */
    public short getAttributes_count() { return attributes_count; }
	/**
	 * Accessor method to <code>attributes</code> table
	 * 
	 * <p>Each value of the attributes table must be an attribute_info structure.<br> 
	 * A method can have any number of optional attributes associated with it.</p>
	 * @return value of <code>access_flags</code> field
	 */
	public attribute_info[] getAttributes() { return attributes; }
	
	/**
	 * Return string value of given <code>access_flag</code>
	 * 
	 * <p>Method access modifier is mapped in <code>access_flag</code> field. Each bit representing one Java access modifier.
	 * The <code>synthetic</code>, <code>bridge</code> modifier will not shown since it's not specify in Java Language Specification</p>
	 * @param access_flag field <code>access_flag</code> value
	 * @return string value of given <code>access_flag</code>
	 */
    public static String getAccessModifier(short access_flag)
	{
		String res="";
		if((access_flag & ACC_PUBLIC) == ACC_PUBLIC)
			res += "public ";
		if((access_flag & ACC_PRIVATE) == ACC_PRIVATE)
			res += "private ";
		if((access_flag & ACC_PROTECTED) == ACC_PROTECTED)
			res += "protected ";
		if((access_flag & ACC_STATIC) == ACC_STATIC)
			res += "static ";
		if((access_flag & ACC_FINAL) == ACC_FINAL)
			res += "final ";
		if((access_flag & ACC_SYNCHRONIZED) == ACC_SYNCHRONIZED)
			res += "synchronized ";
		if((access_flag & ACC_NATIVE) == ACC_NATIVE)
			res += "native ";
		if((access_flag & ACC_ABSTRACT) == ACC_ABSTRACT)
			res += "abstract ";
		if((access_flag & ACC_STRICT) == ACC_STRICT)
			res += "strictfp ";
		return res;
	}
    
   

	public String toString(int indent, cp_info[] constant_pool) {
		String res="";
    	String indentStr = getIndent(indent);
    	res+=indentStr+" access_flags: "+access_flags+" "+getAccessModifier(access_flags)+"\n";
    	try
    	{
    		res+=indentStr+" name_index: "+cp_info.getName(name_index, constant_pool)+"\n";
    	}
    	catch(decompilerException e)
    	{
    		res+=indentStr+" name_index: @"+name_index+"\n";
    	}
    	try
    	{
    		res+=indentStr+" descriptor_index: "+cp_info.getName(descriptor_index, constant_pool)+"\n";
    	}
    	catch(decompilerException e)
    	{
    		res+=indentStr+" descriptor_index: @"+descriptor_index+"\n";
    	}
    	res+=indentStr+" attributes_count: "+attributes_count+"\n";
    	for(int i=0;i<attributes_count;++i)
    	{
    		res+=indentStr+" attributes["+i+"]:\n";
    		res+=attributes[i].toString(indent+1, constant_pool);
    	}
    	return res;
	}
}
