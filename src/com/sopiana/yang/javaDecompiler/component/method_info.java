package com.sopiana.yang.javaDecompiler.component;

import com.sopiana.yang.javaDecompiler.component.sub.attribute_info.Code_attribute;
import com.sopiana.yang.javaDecompiler.instruction.instruction;
import com.sopiana.yang.javaDecompiler.instruction.instructionException;
import com.sopiana.yang.javaDecompiler.util.Util;

public class method_info extends class_info
{
	public static final short ACC_PUBLIC 	= 0x0001; 	//Declared public; may be accessed from outside its package.
	public static final short ACC_PRIVATE 	= 0x0002; 	//Declared private; accessible only within the defining class.
	public static final short ACC_PROTECTED = 0x0004; 	//Declared protected; may be accessed within subclasses.
	public static final short ACC_STATIC 	= 0x0008; 	//Declared static.
	public static final short ACC_FINAL 	= 0x0010; 	//Declared final; must not be overridden (§5.4.5).
	public static final short ACC_SYNCHRONIZED 	= 0x0020; 	//Declared synchronized; invocation is wrapped by a monitor use.
	public static final short ACC_BRIDGE 	= 0x0040; 	//A bridge method, generated by the compiler.
	public static final short ACC_VARARGS 	= 0x0080; 	//Declared with variable number of arguments.
	public static final short ACC_NATIVE 	= 0x0100; 	//Declared native; implemented in a language other than Java.
	public static final short ACC_ABSTRACT 	= 0x0400; 	//Declared abstract; no implementation is provided.
	public static final short ACC_STRICT 	= 0x0800; 	//Declared strictfp; floating-point mode is FP-strict.
	public static final short ACC_SYNTHETIC = 0x1000; 	//Declared synthetic; not present in the source code. 
	
	private short access_flags;
	private short name_index;
	private short descriptor_index;
	private short attributes_count;
	private attribute_info attributes[];	//attributes_count

	public static method_info getInstance(byte[]classFileData, int offset,cp_info[] contant_pool) throws decompilerException
	{
		method_info res = new method_info();
		res.offset = offset;
    	res.access_flags = Util.byte2Short(classFileData,offset);offset+=2;
    	//System.out.format(">>>>%02x",classFileData[offset]);
    	//System.out.format(" %02x\n",classFileData[offset+1]);
    	res.name_index = Util.byte2Short(classFileData,offset);offset+=2;
    	res.descriptor_index = Util.byte2Short(classFileData,offset);offset+=2;
    	res.attributes_count = Util.byte2Short(classFileData,offset);offset+=2;
    	res.attributes = new attribute_info[res.attributes_count];
    	for(int i=0;i<res.attributes_count;++i)
    	{
    		res.attributes[i] = attribute_info.getInstance(classFileData, offset, contant_pool);
    		offset += res.attributes[i].getSize();
    	}
    	return res;
	}
    
    public int getSize()
	{
    	int len = 8;
    	for(int i=0;i<attributes_count;++i)
    		len+=attributes[i].getSize();
    	return len;
	}
    
    public short getAccess_flags() { return access_flags; }
    public int getName_index() { return (name_index&0xFFFF); }
    public int getDescriptor_index() { return descriptor_index; }
	public int getAttributes_count() { return attributes_count; }
	public attribute_info[] getAttributes() { return attributes; }
	
    public static String getAccessModifier(short access_flag)
	{
		String res="";
		if((access_flag & ACC_PUBLIC) == ACC_PUBLIC)
			res += "public ";
		if((access_flag & ACC_PRIVATE) == ACC_PRIVATE)
			res += "private ";
		if((access_flag & ACC_PROTECTED) == ACC_PROTECTED)
			res += "protected ";
		if((access_flag & ACC_STATIC) == ACC_STATIC)
			res += "static ";
		if((access_flag & ACC_FINAL) == ACC_FINAL)
			res += "final ";
		if((access_flag & ACC_SYNCHRONIZED) == ACC_SYNCHRONIZED)
			res += "synchronized ";
		if((access_flag & ACC_NATIVE) == ACC_NATIVE)
			res += "native ";
		if((access_flag & ACC_ABSTRACT) == ACC_ABSTRACT)
			res += "abstract ";
		if((access_flag & ACC_STRICT) == ACC_STRICT)
			res += "strictfp ";
		return res;
	}
    
    public void parseByteCode()
    {
    	for(attribute_info attr:attributes)
    	{
    		
    		if(attr instanceof Code_attribute)
    		{
    			Code_attribute codeAttr = (Code_attribute)attr;
    			byte[] code = codeAttr.getCode();
    			int offset=0;
    			try 
    			{
    			while(offset<code.length)
    			{
    				instruction ins;
					
						ins = instruction.getByteCode(code, offset);
					
	    				System.out.println(ins.getMnemonic());
	    				offset+=ins.getSize();
					} 
					
    			}
    		catch (Exception e) 
			{
				// TODO Auto-generated catch block
				System.out.println("??Unknown Instruction "+String.format("%02x ", code[offset]));
				break;
			}
    		}
    		
    	}
    }
}
